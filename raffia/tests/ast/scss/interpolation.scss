foo[val="bar #{"foo" + " bar"} baz"] {a: b}

@foo #{"directive"} {
  .#{"foo"} { #{"foo-prop"}: #{"foo-val"}; }
}

a /*#{"}*/ {
  margin: 2px;
}

a /*#{#{*/ {
  margin: 2px;
}

div {
  blah: "hello #{2+2} world #{unit(23px)} #{'bloo\n'} blah";
}

a { --#{"foo"}-bar: b; }

[#{$zzz}=foo] { a: b; }
.#{$zzz} { a: b; }
##{$zzz} { a: b; }
:#{$zzz}::#{$zzz} { a: b; }

.js:root #{if(&, '&', '')} {}

.col#{$infix}-#{$i} {}

tr:nth-child(#{$table-striped-order}) {}
tr:nth-of-type(#{$table-striped-order}) {}

@#{$ar-name} #{meta.call($converter, $ar-str, $this-util)} {}
@#{$name} #{"#{$blocks}"} {}

.after-hyphen {
  // We want to treat interpolation as though it's a valid identifier character,
  // which means that if it comes after a hyphen or double-hyphen it should be
  // treated as part of an interpolated identifier that includes that hyphen.
  standalone-single: -#{foo};
  standalone-double: --#{foo};

  // It also means that we shouldn't treat the hyphen as a subtraction
  // operation.
  adjacent-single: #{foo} -#{bar};
  adjacent-double: #{foo} --#{bar};
}

.trailing-non-name-start {
  // We want to treat interpolation as though it's a valid identifier character,
  // which means that if it's followed by a [name character][] that's not a
  // [name start character][] it should still treat that as part of the
  // identifier.
  //
  // [name character]: https://drafts.csswg.org/css-syntax-3/#name-code-point
  // [name start character]: https://drafts.csswg.org/css-syntax-3/#name-start-code-point
  digit: foo#{bar}12;
  hyphen: foo#{bar}-12;
  double-hyphen: foo#{bar}--12;
}
